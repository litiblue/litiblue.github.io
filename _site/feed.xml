<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description></description>
    <pubDate>Sun, 23 Apr 2017 20:15:55 +0900</pubDate>
    
      <item>
        <title>NiFi</title>
        <link>http://localhost:4000/dev/2017/01/21/NiFi.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2017/01/21/NiFi.html</guid>
        <description>&lt;ul&gt;
  &lt;li&gt;데이터 분산, 처리 시스템&lt;/li&gt;
  &lt;li&gt;이종 시스템 간의 데이터 흐름 자동화 플랫폼
    &lt;ul&gt;
      &lt;li&gt;(서로 다른 포멧, 프로토콜, …)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;데이터 라우팅, 변형을 위한 방향성 그래프 지원&lt;/li&gt;
  &lt;li&gt;데이터 흐름의 생성, 모니터링, 제어를 위한 웹 기반 UI 제공&lt;/li&gt;
  &lt;li&gt;런타임에 데이터 흐름을 변경, 우선순위 조정 (Highly configurable)&lt;/li&gt;
  &lt;li&gt;전체 시스템의 데이터 실시간으로 추적하는 Data Provenance&lt;/li&gt;
  &lt;li&gt;커스텀 구성요소(components) 개발을 통한 쉬운 확장&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 21 Jan 2017 17:45:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Git 베스트 프랙티스</title>
        <link>http://localhost:4000/dev/2015/08/19/GitBestPractices.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2015/08/19/GitBestPractices.html</guid>
        <description>&lt;p&gt;본격적으로 Git을 사용하기에 앞서 Git사용시 베스트 프랙티스가 무엇인지 알아보았습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;1-commit-하기-전에-git-diff로-코드-리뷰-버그-방지&quot;&gt;1. commit 하기 전에 git diff로 코드 리뷰 (버그 방지)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;git add –patch (diff를 하나씩 보여주면서 스테이지 여부를 물어봄)&lt;/li&gt;
  &lt;li&gt;git diff –cached (최종 커밋하기 전에 diff로 확인)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-작고-논리적인-커밋-일찍-자주하기&quot;&gt;2. 작고, 논리적인 커밋 (일찍 자주하기)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;잘 관리된 저장소의 커밋 로그는 하나의 스토리다&lt;/li&gt;
  &lt;li&gt;git status와 git diff로 변경사항 리뷰시 단일한 논리적 단위, 단순한 문장으로 설명 되어야함.&lt;/li&gt;
  &lt;li&gt;디버깅시에 커밋 단위가 잘게 나눠져있는 편이 어떤 라인에서 버그가 발생했는지 알기 용이함&lt;/li&gt;
  &lt;li&gt;가이드라인
    &lt;ul&gt;
      &lt;li&gt;절대 하나의 커밋에 여러개의 모듈들을 묶어 넣지 않는다. (여러 모듈이 타이트하게 커플링관계가 아닌 이상)&lt;/li&gt;
      &lt;li&gt;새 모듈을 작성할때 그루터기 함수들을 먼저 작성하고, 돌아와서 그 것들을 채워넣는다.&lt;/li&gt;
      &lt;li&gt;항상 API레벨의 함수들을 작성하고 커밋한다. (그 것들을 사용하는 함수들을 작성하고 커밋하기전에)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-깨끗한-커밋-히스토리를-남겨라&quot;&gt;3. 깨끗한 커밋 히스토리를 남겨라&lt;/h3&gt;
&lt;p&gt;git merge를 많이 쓰게되면 커밋 히스토리를 읽기 어려워짐&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;git rebase와 git merge의 조합을 사용할 것&lt;/li&gt;
  &lt;li&gt;push 전에 rebase할 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-절대-공유된-커밋은-리베이스-하지-말라&quot;&gt;4. 절대 공유된 커밋은 리베이스 하지 말라&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;규칙 : 한 번 원격 저장소에 푸쉬한 커밋은 리베이스하지 않기&lt;/li&gt;
  &lt;li&gt;이렇게 하면 다른 사람들의 코드를 망가뜨리지 않게 해주고, 내가 수정한 버그나 실수의 기록도 보존시켜준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-용도에-알맞게-pull-request를-사용하라&quot;&gt;5. 용도에 알맞게 pull request를 사용하라.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;팀원들이 무엇이 어떻게 돌아가는지 알 수 있게 해줌 (변경사항 추적, 커밋 연계, 개발 중 협업, 머지 전 코드 리뷰)&lt;/li&gt;
  &lt;li&gt;머지 커밋이 눈에 띄는게 유일한 단점이긴 하지만, 팀으로 일할 때 이 점은 상쇄된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-명령어를-위한-alise를-사용할-것-gitconfig에-추가&quot;&gt;6. 명령어를 위한 alise를 사용할 것 (~/.gitconfig에 추가)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[alias]
lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s \
%Cgreen(%cr, %cn)%Creset' --abbrev-commit --date=relative

hist = log --graph --pretty=format:'%h %ad | %s%d [%an]' --date=short

last = log -1 HEAD
unstage = reset HEAD --
amend = commit --amend -C HEAD
co = checkout
ci = commit
st = status
br = branch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;참고자료&quot;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://sethrobertson.github.io/GitBestPractices/&quot;&gt;https://sethrobertson.github.io/GitBestPractices/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://chriskottom.com/blog/2014/02/a-few-modest-best-practices-for-git/&quot;&gt;http://chriskottom.com/blog/2014/02/a-few-modest-best-practices-for-git/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.lullabot.com/articles/git-best-practices-workflow-guidelines&quot;&gt;https://www.lullabot.com/articles/git-best-practices-workflow-guidelines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 19 Aug 2015 17:45:00 +0900</pubDate>
      </item>
    
      <item>
        <title>더 나은 Git 사용을 위한 명령어</title>
        <link>http://localhost:4000/dev/2015/08/17/BetterGit.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2015/08/17/BetterGit.html</guid>
        <description>&lt;p&gt;이미 Git을 어느 정도 사용해보았고, branch의 merge개념도 어느정도 익숙한 분들을 위한 내용입니다. 핵심적인 내용만 간단히 정리해놓았으니, 보다 자세한 내용을 원하시는 분들은 뒤에 있는 참고 사이트를 보시길 바랍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;1-merging-vs-rebasing&quot;&gt;1. merging vs rebasing&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/merge_before-New-Page.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;git rebase는 git merge와 같은 문제를 해결하기 위한 것으로, 브랜치의 변경사항을 다른 브랜치에 적용합니다. 위 그림 처럼 Master 브랜치에서 갈라져 나온 Feature 브랜치에서 작업을 하고 있는데, Master 브랜치가 변경 되었다면 변경 사항 반영을 위해 rebase 또는 merge를 택할 수 있습니다.&lt;/p&gt;

&lt;p&gt;먼저 merge의 경우를 살펴보겠습니다. 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout feature&lt;br /&gt;
git merge master&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/merge_after.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 형태로 추가적인 커밋이 하나 추가된 것을 볼 수 있습니다. 머지의 장점은 비파괴적(non-destructive)이라는 것입니다, 기존 커밋들은 아무것도 바뀌지 않았습니다. rebase가 가지고 있는 잠재적 위험 요소를 제거합니다. 하지만 정돈되지않은 머지커밋들이 늘어나면 다른 개발자가 히스토리를 읽기 어려워 질수도 있습니다.&lt;/p&gt;

&lt;p&gt;리베이스의 경우를 살펴 봅시다. 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout feature&lt;br /&gt;
git rebase master&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feature 브랜치 전체를 Master 브랜치의 끝으로 이동하고, Master 브랜치의 모든 새로운 커밋을 반영했습니다. 머지와 달리 새로운 커밋들을 생성하면서 히스토리를 다시 쓰게되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/rebase.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이미지는 위와 같습니다. 장점은 깨끗한 히스토리를 얻게된다는 것입니다. 완전히 선형적인 구조이기 때문에 git log, git bisect, git gitk등으로 탐색하기가 쉽습니다. 이렇게 새 것같은 커밋 히스토리에는 트레이드오프가 있습니다. 히스토리를 다시 씀으로인해 잠재적으로 협업 워크플로우에 큰 지장을 초래할 수도 있기에 주의해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;인터랙티브 리베이싱&lt;/strong&gt;이라는 것도 있습니다. 이를 이용하면 현재 작업중인 브랜치에서 여러개의 커밋을 한꺼번에 수정할 수 있습니다. 커밋의 순서를 바꾸거나 합치기 등이 가능합니다. 보통 feature 브랜치를 master 브랜치로 머지하기 전 지저분한 히스토리를 정리하기위해 사용합니다.&lt;/p&gt;

&lt;p&gt;명령은 i 옵션을 주면 됩니다. 아래는 최근 3개의 커밋을 수정하기위한 명령입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git rebase -i HEAD~3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;실행하면 편집기가 열리고 아래와 같이 각 각의 커밋 앞에 수행할 명령(pick, fixup등)을 적게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;pick 33d5b7a Message for commit #1&lt;br /&gt;
pick 9480b3d Message for commit #2&lt;br /&gt;
pick 5c67e61 Message for commit #3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 리스트는 리베이스가 끝난 뒤 브랜치가 어떻게 보여질 것인가를 정의하는 것입니다. 순서를 바꿀수도 있고, 아래와 같이 fixup으로 바꾼 뒤 저장하면 두 번째 커밋이 바로 전 커밋인 첫 번째 커밋으로 합쳐지게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;pick 33d5b7a Message for commit #1&lt;br /&gt;
fixup 9480b3d Message for commit #2&lt;br /&gt;
pick 5c67e61 Message for commit #3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2-커밋을-가리키는-상대적인-방법&quot;&gt;2. 커밋을 가리키는 상대적인 방법&lt;/h3&gt;

&lt;p&gt;커밋을 가리키는 다양한 방법들이 있지만 여기서는 쉽고 자주 쓰이는 상대적인 방법에 대해 설명합니다. HEAD^ 과 HEAD~ 둘 다 HEAD를 기준으로 부모를 가리키는데, HEAD^숫자 와 HEAD~숫자인 경우 헷갈리지 말아야할 것은 ^는 머지 커밋이 있는 경우 여러 부모가 있을 때 몇 번째 부모인지를 나타내는 반면 ~는 조부모를 가리킵니다. 다음 예제를 보면 좀 더 명확히 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ref.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3-되돌리기-reset-checkout-revert&quot;&gt;3. 되돌리기 (reset, checkout, revert)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;31-reset&quot;&gt;3.1 reset&lt;/h4&gt;

&lt;p&gt;브랜치의 끝을 다른 커밋으로 이동하는 것입니다. 다음과 같이 커밋들을 지우는데 사용 가능합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout hotfix&lt;br /&gt;
git reset HEAD~2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 하면 끝의 두 커밋은 댕글링 커밋(가비지 컬렉션 대상)이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/reset.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;옵션에 따라 적용되는 범위가 다릅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;soft : 커밋 히스토리에만 영향을 줍니다.&lt;/li&gt;
  &lt;li&gt;mixed : 기본값이며, 커밋 히스토리와 스테이지에 영향을 줍니다.&lt;/li&gt;
  &lt;li&gt;hard : 커밋 히스토리, 스테이지, 워킹디렉토리 모두에 영향을 줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가장 많이 쓰는 경우는 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git reset –mixed HEAD^ : 최근 커밋 취소 (스테이지도 함께 취소)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;32-checkout&quot;&gt;3.2 checkout&lt;/h4&gt;

&lt;p&gt;브랜치를 checkout했던 것처럼 커밋 주소를 통해서도 checkout하는것이 가능합니다. 브랜치의 경우와 마찬가지로 HEAD참조를 특정한 커밋으로 옮깁니다. 예를 들면 다음 명령은 현재 커밋의 조부모로 체크아웃 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout HEAD~2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/checkout.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오래된 버전의 프로젝트를 살펴볼때 유용하지만, 현재 HEAD를 가리키는 브랜치 참조가 없어서 detached HEAD 상태가 됩니다. 이 상태에서 커밋을 하고 다른 브랜치로 스위칭을 하면 변경 사항들을 잃어버릴 수가 있습니다. 그래서 커밋을 할 때는 새로운 브랜치를 생성하는게 좋습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;33-revert&quot;&gt;3.3 revert&lt;/h4&gt;

&lt;p&gt;새로운 커밋을 생성하여 되돌리기를 하는 방법입니다. 커밋 히스토리를 건드리지 않기 때문에 안전합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git revert HEAD~2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/revert.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림을 보면 B라는 커밋이 새로 생성되었는데, 두 번째 전으로 revert되었기 때문에 A커밋의 상태와 동일합니다. 원격 저장소에 푸쉬한 경우 이 방법으로 되돌리기가 가능합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4-stash&quot;&gt;4. stash&lt;/h3&gt;

&lt;p&gt;스테이지에 있는 파일들을 스택에 잠시 저장해두는 명령어 입니다. 어떤 브랜치에서 작업중인데 다른 브랜치로 잠시 이동(checkout)해야 할 경우 유용합니다. 다른 브랜치에서의 작업이 끝나면 다시 돌아온 뒤 스택에서 꺼내면 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;git stash : 스테이지에 있는 파일들과 tracked 이면서 modified인 파일들을 스택에 저장합니다.&lt;/li&gt;
  &lt;li&gt;git list : 스택에 저장된 것들을 목록을 보여줍니다.&lt;/li&gt;
  &lt;li&gt;git pop : 스택에서 꺼내서 현재 브랜치에 적용합니다. 이 때 stash 했던 브랜치여야 할 필요는 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;참고reference&quot;&gt;참고(reference)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.atlassian.com/git/tutorials/advanced-overview/&quot;&gt;http://www.atlassian.com/git/tutorials/advanced-overview/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/ko/v2/&quot;&gt;http://git-scm.com/book/ko/v2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 17 Aug 2015 17:45:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
