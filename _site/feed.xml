<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description></description>
    <pubDate>Sat, 14 Dec 2019 15:26:04 +0900</pubDate>
    
      <item>
        <title>독서노트 - 오브젝트 (2)</title>
        <link>http://localhost:4000/dev/2019/12/13/Book-Object-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2019/12/13/Book-Object-2.html</guid>
        <description>&lt;p&gt;P.51 ~ P.85 요약&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;객체지향-프로그래밍&quot;&gt;객체지향 프로그래밍&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다&lt;/li&gt;
  &lt;li&gt;코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다&lt;/li&gt;
  &lt;li&gt;의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 잘 보여준다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다&lt;/li&gt;
  &lt;li&gt;추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라&lt;/li&gt;
  &lt;li&gt;유연성이 필요한 곳에 추상화를 사용하라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다&lt;/li&gt;
  &lt;li&gt;상속은 실행 시점에 객체의 종류를 변경하는 것이 불가능하다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;역할-책임-협력&quot;&gt;역할, 책임, 협력&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적인 존재다&lt;/li&gt;
  &lt;li&gt;어플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다 그 객체가 어떤 협력에 참여하고 있기 때문이다&lt;/li&gt;
  &lt;li&gt;협력이 존재하기 때문에 객체가 존재하는 것이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;크레이그 라만은 객체의 책임을 크게 하는 것과 아는 것의 두가지 범주로 나누어 세분화하고 있다&lt;/li&gt;
  &lt;li&gt;객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다&lt;/li&gt;
  &lt;li&gt;객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것이다&lt;/li&gt;
  &lt;li&gt;객체의 구현 방법은 상대적으로 책임보다는 덜 중요하며 책임을 결정한 다음에 고민해도 늦지 않다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다이어그램 대신 CRC 카드를 사용하는 이유 - 사람들은 아무것도 없는 상태에서 새로운 것을 만들어내기보다는 이미 존재하는 구체적이고 실재적인 것을 관찰하고 수정하고 그에 대한 피드백을 받으며 작업할 때 좀 더 효과적으로 일한다&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 13 Dec 2019 17:45:00 +0900</pubDate>
      </item>
    
      <item>
        <title>독서노트 - 오브젝트 (1)</title>
        <link>http://localhost:4000/dev/2019/12/06/Book-Object.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2019/12/06/Book-Object.html</guid>
        <description>&lt;p&gt;처음 부터 P.50 까지 요약&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래밍 패러다임은 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 한다&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어와 프로그래밍 패러다임을 분리해서 설명할 수 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어 모듈의 목적 (클린 소프트웨어 - 로버트 마틴)
    &lt;ul&gt;
      &lt;li&gt;실행 중에 제대로 동작하는 것&lt;/li&gt;
      &lt;li&gt;간단한 작업만으로도 변경이 가능&lt;/li&gt;
      &lt;li&gt;개발자가 쉽게 읽고 이해할 수 었어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;티켓 판매 어플리케이션&lt;/li&gt;
  &lt;li&gt;관람객과 판매원이 소극장의 통제를 받는 수동적인 존재이며 우리의 상식과 다르게 동작하는 것이 문제&lt;/li&gt;
  &lt;li&gt;심각한 문제는 Audience와 TicketSeller를 변경할 경우 Theater도 함께 변경해야 한다는 사실&lt;/li&gt;
  &lt;li&gt;Theater가 Audience와 TicketSeller에 관해 세세한 부분까지 알지 못하도록 정보를 차단해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있다&lt;/li&gt;
  &lt;li&gt;객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다&lt;/li&gt;
  &lt;li&gt;외부 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 위한 지름길이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;무생물도 스스로 행동하고 자신을 책임지는 자율적인 존재로 취급하여 객체를 설계하는 원칙을 가리켜 의인화라고 부른다&lt;/li&gt;
  &lt;li&gt;이해하기 쉽고 변경하기 쉬운 코드를 작성하고 싶다면 차라리 한 편의 에니메이션을 만든다고 생각하라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변경을 수용할 수 있는 설계가 중요한 이유는 요구사항이 항상 변경되기 때문이다&lt;/li&gt;
  &lt;li&gt;요구사항 변경은 필연적으로 코드 수정을 초래하고, 코드 수정은 버그가 발생할 가능성을 높인다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체 지향적으로 생각하고 싶다면 객체를 고립된 존재로 바라보지 말고 협력에 참여하는 협력자로 바라보아야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다.&lt;/li&gt;
  &lt;li&gt;클래스를 개발할 때마다 인터페이스과 구현을 깔끔하게 분리하기 위해 노력해야 한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 06 Dec 2019 17:45:00 +0900</pubDate>
      </item>
    
      <item>
        <title>온더 서류 전형 블록체인 문제 풀이</title>
        <link>http://localhost:4000/dev/2018/07/03/BlockchainQuiz.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2018/07/03/BlockchainQuiz.html</guid>
        <description>&lt;p&gt;블록체인 회사 온더의 서류 전형 문제를 풀어보았습니다. 꽤 어렵다고 느껴져 모두 풀지는 못하였고 해결한 문항에 대해서만 문제와 답을 함께 올립니다. 모든 문항은 &lt;a href=&quot;https://medium.com/onther-tech/%EC%98%A8%EB%8D%94-%EA%B3%B5%EA%B0%9C%EC%B1%84%EC%9A%A9-%EA%B3%B5%EA%B3%A0-cc408a4bf763&quot;&gt;온더 공개채용 공고&lt;/a&gt; 에서 확인할 수 있습니다.
실무 경험에서 우러나온 수준 높은 문제라고 생각되니 블록체인에 관심이 있는 분이라면 꼭 풀어보시는 것을 추천드립니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;온더-서류-전형-문답&quot;&gt;온더 서류 전형 문답&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-다음-명제에-대한-참거짓-여부를-판단하고-근거를-제시하시오&quot;&gt;2. 다음 명제에 대한 참거짓 여부를 판단하고 근거를 제시하시오.&lt;/h4&gt;

&lt;p&gt;“Solidity의 keccak함수의 연산은 EVM의 스택머신에서 이루어진다.”&lt;/p&gt;

&lt;p&gt;스택머신을 무엇으로 정의하느냐에 따라 다르게 해석할 수 있다. EVM 자체가 스택머신이라는 점에선 참이지만 연산 과정만 본다면 스택을 사용하지 않기 때문에 거짓이다.&lt;/p&gt;

&lt;p&gt;keccak함수 실행시 입력 데이터 주소를 스택에서 pop을 통해 가져오고 결과를 스택에 push하므로 스택머신에서 이루어진다고 볼 수 있다. 하지만 keccak 함수의 연산 자체는 스택이 아닌 메모리에서 이루어진다.&lt;/p&gt;

&lt;p&gt;다음 주소에서 keccak 함수의 연산 과정을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ethereum/py-evm/blob/master/evm/vm/logic/sha3.py&quot;&gt;https://github.com/ethereum/py-evm/blob/master/evm/vm/logic/sha3.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-0x60-옵코드opcode는-어떤-명령인가&quot;&gt;3. 0x60 옵코드(OPCODE)는 어떤 명령인가?&lt;/h4&gt;

&lt;p&gt;PUSH1으로 스택에 1바이트를 넣는 명령이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUSH1 0x60 PUSH1 0x40 MSTORE
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위와 같은 코드의 바이트 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;6060604052&lt;/code&gt; 인데 &lt;code class=&quot;highlighter-rouge&quot;&gt;PUSH1&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x60&lt;/code&gt; 이고 &lt;code class=&quot;highlighter-rouge&quot;&gt;MSTORE&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x52&lt;/code&gt; 이기 때문이다. 코드가 실행되는 과정은 스택에 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x60&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40&lt;/code&gt;이 차례로 들어가고 &lt;code class=&quot;highlighter-rouge&quot;&gt;MSTORE&lt;/code&gt;가 실행되어 값&lt;code class=&quot;highlighter-rouge&quot;&gt;0x60&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40&lt;/code&gt;위치에 저장 한다. 이 경우 스택에 들어있던 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x60&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x40&lt;/code&gt;두 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;MSTORE&lt;/code&gt; 연산에 의해 사용 되었으므로 스택은 비워지게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-다음-명제에-대한-참거짓-여부를-판단하고-근거를-제시하시오&quot;&gt;4. 다음 명제에 대한 참거짓 여부를 판단하고 근거를 제시하시오.&lt;/h4&gt;

&lt;p&gt;“EA가 CA한테 이더를 보냈다. CA의 balance와 storageRoot는 모두 바뀐다. (단, CA 코드에 msg.value를 사용하는 부분은 없다)”&lt;/p&gt;

&lt;p&gt;CA의 balance는 바뀌지만 storageRoot는 바뀌지 않으므로 위 명제는 거짓이다.&lt;/p&gt;

&lt;p&gt;State Trie에 각 account별 상태 정보 nonce, balance, storageRoot, codeHash가 저장 되는데 이 중 storageRoot는 컨트랙트 데이터가 저장되어있는 Storage Trie가 변경되는 경우에만 바뀐다. EA가 CA한테 이더를 보낼 때는 두 account의 balance만 변하게 되며 컨트랙트의 변수를 변경하는 것은 아니므로 storageRoot는 바뀌지 않고 balance만 바뀌게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-evm-옵코드-중-jump와-jumpdest의-차이와-역할에-대해서-서술하시오&quot;&gt;6. EVM 옵코드 중 JUMP와 JUMPDEST의 차이와 역할에 대해서 서술하시오.&lt;/h4&gt;

&lt;p&gt;명령문의 흐름 제어에 쓰이는 옵코드로 JUMPDEST로 지정된 곳으로만 JUMP를 통해 이동 가능하다. 컴파일러 버그 등 얘기치 못한 보안 문제 발생시 약속 되지 않은 코드 실행을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-모든-거래내역이-공개되어-있음에도-불구하고-해커가-비트코인을-훔쳐갔을-때-이를-추적하기-어려운-이유는-무엇인가&quot;&gt;7. 모든 거래내역이 공개되어 있음에도 불구하고, 해커가 비트코인을 훔쳐갔을 때 이를 추적하기 어려운 이유는 무엇인가?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;주소와 거래내역이 모두 공개 되어있음에도 불구하고 신원 정보는 알 수가 없음&lt;/li&gt;
  &lt;li&gt;TOR 브라우저나 VPN 등을 사용하여 지갑에 접근하면 접근 기록 마져도 가릴 수 있음&lt;/li&gt;
  &lt;li&gt;믹서 툴을 이용하면 주소와 거래 내역을 대규모로 생성하여 실제 해커의 주소를 추적하는 아주 어렵게 만들 수 있음&lt;/li&gt;
  &lt;li&gt;거래소에서 환전을 하거나 물건을 구입할 때 신원 정보를 알 수 있게 되지만 그 시점을 알기 힘듦&lt;/li&gt;
  &lt;li&gt;다른 암호화폐로 바꾸거나 다크넷에서 사용하면 추적이 힘들어짐&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-payble-모디파이어modifier에-대해서-설명하고-payable-모디파이어가-없는-ico-컨트랙트는-만들어질-수-있는가-있다면-그-이유는-무엇인가&quot;&gt;9. payble 모디파이어(modifier)에 대해서 설명하고 payable 모디파이어가 없는 ICO 컨트랙트는 만들어질 수 있는가? 있다면 그 이유는 무엇인가?&lt;/h4&gt;

&lt;p&gt;모디파이어는 특정 함수에 미리 정의된 속성(기능)을 추가하는 것으로 payable 모디파이어가 지정된 함수는 이더 송금과 함께 호출할 수 있다. 또한 이름 없는 fallback 함수를 payable과 함께 선언하여 함수 지정없이도 이더를 송금하면 실행되도록 할 수 있다.&lt;/p&gt;

&lt;p&gt;payable 모디파이어가 없는 ICO 컨트랙트를 만들고자 한다면 다른 account를 통해 이더를 받은 것을 확인한 뒤 토큰 전송 함수를 호출하는 방식으로 구현 가능하다. ICO에 참여하고자 하는 사람 마다 이더리움 account를 생성하여 할당 함과 동시에 ICO토큰을 받을 account 주소를 입력 받아 주기적으로 account 잔고를 확인하여 입금 되었을 경우엔 입력 받은 account 주소로 토큰을 전송한다. 이 방식을 사용하기 위해선 컨트랙트 외부에서 실행되는 프로세스가 필요할 것으로 보인다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;13-truffle-migratetruffle-compiletruffle-test-각각의-명령어는-truffle에서-어떤-역할을-하는지-서술하시오&quot;&gt;13. truffle migrate,truffle compile,truffle test 각각의 명령어는 Truffle에서 어떤 역할을 하는지 서술하시오.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;(1) truffle migrate&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컨트랙트를 truffle.js에 있는 이더리움 네트워크에 배포&lt;/li&gt;
  &lt;li&gt;프로젝트의 migrations 디렉토리에 있는 마이그레이션 스크립트를 실행&lt;/li&gt;
  &lt;li&gt;이 전에 성공한 마이그레이션이 있다면 그 이후에 만들어진 부분만 실행&lt;/li&gt;
  &lt;li&gt;순서 지정을 위해 마이그레이션 파일 앞에 숫자를 포함&lt;/li&gt;
  &lt;li&gt;artifacts.require로 컨트랙트를 불러온 뒤 deploy로 배포하며 link로 컨트랙트 간 연결&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(2) truffle compile&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;solidity로 작성한 컨트랙트를 EVM이 이해할 수 있는 바이트코드로 컴파일&lt;/li&gt;
  &lt;li&gt;build/contracts 디렉토리에 결과가 json 형태로 저장되어 배포 시에 사용&lt;/li&gt;
  &lt;li&gt;다른 파일 및 라이브러리를 import 하는 경우 함께 컴파일&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(3) truffle test&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자바스크립트, 솔리디티 두 언어를 모두 지원&lt;/li&gt;
  &lt;li&gt;test 디렉토리에 있는 테스트 파일 들이 실행되며 경로를 지정하는 것도 가능&lt;/li&gt;
  &lt;li&gt;테스트 할 때마다 새로운 환경에서 실행&lt;/li&gt;
  &lt;li&gt;다음 순서로 실행 : 컨트랙트 컴파일 -&amp;gt; 마이그레이션을 통해 네트워크에 배포 -&amp;gt; 배포된 컨트랙트를 테스트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;14-github에서-solidity-코드가-알록달록linter하게-보이기-위해서는-어떤-작업을-해야하는가&quot;&gt;14. github에서 solidity 코드가 알록달록(linter)하게 보이기 위해서는 어떤 작업을 해야하는가?&lt;/h4&gt;

&lt;p&gt;저장소의 root에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitattributes&lt;/code&gt;파일을 추가하고 파일 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.sol linguist-language=Solidity&lt;/code&gt;를 추가&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;15-이더리움-계정-생성-간에는-뉴모닉-단어를-이용할-수-있다-뉴모닉이-만들-수-있는-계정-갯수의-한도는-있는가-그렇다면-혹은-그렇지-않다면-그-이유를-서술하시오&quot;&gt;15. 이더리움 계정 생성 간에는 뉴모닉 단어를 이용할 수 있다. 뉴모닉이 만들 수 있는 계정 갯수의 한도는 있는가? 그렇다면 혹은 그렇지 않다면 그 이유를 서술하시오.&lt;/h4&gt;

&lt;p&gt;만들 수 있는 계정 개수의 한도는 없다. 뉴모닉 단어를 이용하여 HD 월렛의 시드를 생성하고 그 시드를 이용하여 root 계정을 만들고 그 것을 이용하여 계층 구조의 하위 계정을 무제한으로 만들 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;16-패러티-멀티시그-해킹httpsparitytechiosecurity-alert-2의-구조와-원리를-설명하시오&quot;&gt;16. 패러티 멀티시그 해킹(&lt;a href=&quot;https://paritytech.io/security-alert-2/&quot;&gt;https://paritytech.io/security-alert-2/)&lt;/a&gt;의 구조와 원리를 설명하시오.&lt;/h4&gt;

&lt;p&gt;함수 선언과 맞지않는 모든 함수 호출은 delegatecall 로 호출 되도록 되어있기 때문에 라이브러리의 모든 public 함수를 누구나 호출할 수 있게 되어버린다. 해커는 컨트랙트의 소유권을 변경하는 initWallet 함수를 호출하여 소유권을 획득한 뒤 execute 함수를 호출하여 모든 잔고를 자신에게 송금한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;17-솔리디티-proxy-pattern에-대해서-설명하시오&quot;&gt;17. 솔리디티 Proxy Pattern에 대해서 설명하시오.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;한 번 배포된 코드(라이브러리)를 업그레이드(취약점 해결)하기 위하여 사용&lt;/li&gt;
  &lt;li&gt;모든 메시지콜을 Proxy 컨트랙트를 통하도록 하여 최신 버전의 컨트랙트로 리다이렉트 되도록 함&lt;/li&gt;
  &lt;li&gt;새 버전의 컨트랙트를 먼저 배포하고 Proxy가 새로운 주소를 가리키도록 업데이트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;18-call-delegate-call-static-call의-차이에-대해서-설명하시오&quot;&gt;18. call, delegate call, static call의 차이에 대해서 설명하시오.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;call&lt;/strong&gt;&lt;br /&gt;
특정 주소의 다른 컨트랙트를 데이터, 가스, 이더와 함께 실행한다. 컨트랙트 A를 통해 컨트랙트 B 호출시 컨텍스트는 컨트랙트 B의 컨텍스트로 변경되며 msg.sender는 컨트랙트 A가 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;delegate call&lt;/strong&gt;&lt;br /&gt;
컨트랙트 A를 통해 컨트랙트 B 호출시 컨텍스트는 바뀌지 않으며 msg.sender와 msg.value가 컨트랙트 A 호출시와 같다. 오직 코드만 컨트랙트 B의 것을 사용한다고 보면 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;static call&lt;/strong&gt;&lt;br /&gt;
상태를 변경하는 경우와 읽기만 하는 경우를 구분하기 위하여 사용한다. static call을 사용하면 다른 컨트랙트로 리다이랙트 되는 경우에도 상태 변경이 일어나지 않음을 확실히 보장할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;19-solidity와-vyper의-차이점과-두-언어의-장단점에-대해서-각각-설명하시오&quot;&gt;19. solidity와 Vyper의 차이점과 두 언어의 장단점에 대해서 각각 설명하시오.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;두 언어의 차이점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개발 철학 및 추구하는 방향&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Vyper는 언어 차원에서 높은 가독성 및 Auditability를 지원하여 쉽게 이해할 수 있는 에러 없는 코드를 지향&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Modifier 지원 여부&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;solidity는 함수에 Modifier를 지정할 수 있고 코드 실행 전후 체크에 사용하며 상태가 변경 되기도 함&lt;/li&gt;
      &lt;li&gt;Vyper는 Modifier의 사용이 가독성을 해치고 오해를 불러올 수 있기 때문에 지원하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Vyper가 지원하지 않는 기능&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;클래스 상속 : 코드를 이해하기 어렵게 만든다고 생각하여 이를 지원하지 않음&lt;/li&gt;
      &lt;li&gt;인라인 어셈블리 : 변수명을 읽거나 변경되는 코드를 찾기 힘들게 만든다고 생각하여 지원하지 않음&lt;/li&gt;
      &lt;li&gt;함수 오버로딩 : 어떤 함수가 실행 되는지 알기 힘들게 하고 코드에서 함수를 찾기 힘들게 하므로 지원하지 않음&lt;/li&gt;
      &lt;li&gt;재귀호출 및 무한-길이 반복 문 : 가스의 제한을 지정할 수없어 가스제한 공격에 노출될 수 있어 지원하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;두 언어의 장단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;언어적인 측면에서 solidity가 더 많은 기능을 지원 하는 반면 Vyper는 몇 몇 기능을 일부러 지원하지 않음으로 높은 가독성 및 보안을 달성하고자 함. 개발 목적에 따라 solidity 또는 Vyper를 택하면 될 것으로 보임&lt;/li&gt;
  &lt;li&gt;단, Vyper를 택한다고 해도 현 시점에 사용 가능한 라이브러리의 수가 상대적으로 적고 이미 solidity에 익숙해져 있는 경우 기존 solidity 개발 환경이 더 나을 것으로 보임&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;20-on의-시간복잡도를-가진-알고리즘은-퍼블릭-이더리움에서-동작-가능한가-가능하다면-혹은-가능하지-않다면-그-이유는-무엇인지-서술하시오&quot;&gt;20. O(n)의 시간복잡도를 가진 알고리즘은 퍼블릭 이더리움에서 동작 가능한가? 가능하다면 혹은 가능하지 않다면 그 이유는 무엇인지 서술하시오.&lt;/h4&gt;

&lt;p&gt;이론적으로는 동작 가능 하지만 비용 및 시간이 매우 많이 들기 때문에 현실 적으로 동작 불가능하다.&lt;/p&gt;

&lt;p&gt;이더리움의 경우 마이닝 및 벨리데이션 과정 중에 컨트랙트가 실행 되므로 전체 마이너 및 노드 개수가 m개라고 가정했을 때 O(n)의 시간복잡도를 가진 알고리즘이 컨트랙트 내에서 실행 된다면 전체 네트워크 상의 시간 복잡도가 O(n * m) 이다. 노드는 병렬적으로 구성 되어있으므로 실제 실행에 걸리는 시간은 m이 상쇄되어 O(n)이라고 생각 해본다면 별 다른 문제가 없다고 생각할 수도 있지만 비용 면에서 생각 해본다면 그렇지 않다.&lt;/p&gt;

&lt;p&gt;단순히 두 숫자를 더하는 연산을 n번 하는 알고리즘이 있다고 한다면 ADD 연산이 3의 가스를 소모하므로 3n 만큼 가스가 들고 이 경우 n이 100만 이라고 한다면 300만 가스가 들고 가스 당 0.00002 USD의 비용이 든다면 총 20 USD 라는 비용이 들게된다. 그런데 실제로 for문 한 번 돌리려고 해도 JUMPDEST, DUP3, AND, ADD 등 수 많은 연산이 필요하다. 게다가 실제 O(n)의 시간 복잡도를 가지는 알고리즘이 단순히 더하는 연산만 하지는 않을 것이다.&lt;/p&gt;

&lt;p&gt;이런 사실을 반영하여 어림 잡아 연산 비용에 100배를 한다면 20000 USD 라고 해도 원화로 2000만원은 족히 들게 된다. for문 한 번 돌리는데 이 정도의 비용이 들게되니 현실적으로 O(n)의 알고리즘을 퍼블릭 이더리움에서 동작하는 것은 불가능 하다 이런 알고리즘을 실행해야 하는 경우 메인 체인이 아닌 off chain등을 이용해야 할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;22-ico-트릴레마에-대해서-설명하시오&quot;&gt;22. ICO 트릴레마에 대해서 설명하시오.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;(1) 수량의 상한선 :&lt;/strong&gt; 규제 등의 위험을 피하기 위해 판매 금액에는 한도가 있어야 함&lt;br /&gt;
&lt;strong&gt;(2) 중앙 은행 :&lt;/strong&gt; 토큰 발행인은 시장을 통제할 수 있을 만큼 매우 큰 비율의 토큰이 가진채로 끝낼 수 없어야 한다&lt;br /&gt;
&lt;strong&gt;(3) 효율성 :&lt;/strong&gt; 토큰 세일이 중대한 경제적 비효율 또는 손실을 초래 해서는 안 된다&lt;/p&gt;

&lt;p&gt;다음과 같은 이유로 위 세가지를 동시에 만족시킬 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2)&lt;/strong&gt;를 만족 시키려면 전부 또는 대부분의 토큰을 판매하여 판매 가치가 판매 가격에 비례하게 해야한다. &lt;strong&gt;(1)&lt;/strong&gt;를 만족시키려면 가격의 상한선을 두면 되지만 판매 수량의 균형 가격이 설정한 한도를 초과할 가능성이 있으므로 부족한 부분이 있어야 하는데 이 때문에 필연적으로 큰 손실이 발생하게 되어 &lt;strong&gt;(3)&lt;/strong&gt;과 모순된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;24-토큰의-분류-중-work-token의-개념을-설명하고-work-token의-이상적인-형태에-대해-예를-들어-서술2가지-이상하시오&quot;&gt;24. 토큰의 분류 중 Work Token의 개념을 설명하고 Work Token의 이상적인 형태에 대해 예를 들어 서술(2가지 이상)하시오.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Work Token의 정의&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;토큰 소유자에게 네트워크에 참여할 수 있는 권한을 주며 악의적인 행동은 처벌하고 무임 승차에 불이익을 줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;보상/처벌 메커니즘&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 토큰을 예치금으로 걸어 놓는다&lt;/li&gt;
  &lt;li&gt;올바르게 일했을 경우 배당금을 받고 예치금도 돌려 받을 수 있음&lt;/li&gt;
  &lt;li&gt;그러지 않았을 경우 배당금을 받지 못하고 예치금도 잃게 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;무임 승차 방지&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;올바르게 일 했을 경우에만 배당금을 지급하여 무임 승차 문제를 해결&lt;/li&gt;
  &lt;li&gt;토큰을 사용하지 않는 소유자는 토큰을 잃지도 얻지도 않음&lt;/li&gt;
  &lt;li&gt;적극적인 참여 없이도 여전히 네트워크 가치 상승으로 이익을 얻을 수 있지만 참여를 통한 기회는 잃게됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Work Token의 이상적인 형태 (1)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;보상/처벌 모델에도 불구하고 여전히 네트워크에 참여할 의도가 없는 토큰 소유자들이 다수 존재하는 문제를 해결&lt;/li&gt;
  &lt;li&gt;최대한 많은 토큰 사용자들이 네트워크에 참여할 수 있도록해야 함&lt;/li&gt;
  &lt;li&gt;네트워크에 참여하기 위하여 토큰을 구매하기 위한 장벽이 낮아야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Numerai의 경우&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ICO에서 토큰을 파는 대신 데이터 사이언티스트들에게 주었음&lt;/li&gt;
  &lt;li&gt;결과적으로 토큰을 가장 많이 가지고 있는 소유자가 또한 플랫폼의 가장 큰 사용자가 됨&lt;/li&gt;
  &lt;li&gt;이 들은 토큰을 얻기위해 돈을 쓸 필요가 없기 때문에 집입 장벽이 낮아짐&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Work Token의 이상적인 형태 (2)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;보상/처벌 모델이 잘 동작해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;AUGUR의 경우&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예측 시장 개설자가 등록한 정보를 바탕으로 사용자들이 쉽게 결과를 판단할 수 있게 되어있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;27-solidity에서-함수-인자로-전달된-파라미터-a를-함수-내부에서-소괄호로-감쌌다-이것이-무슨-의미를-갖는지-서술하시오&quot;&gt;27. Solidity에서 함수 인자로 전달된 파라미터 a를 함수 내부에서 소괄호로 감쌌다. 이것이 무슨 의미를 갖는지 서술하시오.&lt;/h4&gt;

&lt;p&gt;별 다른 의미는 없으며 사용 되지 않는 파라미터 때문에 linter가 경고를 표시하는 것을 방지하기 위한 용도로 쓰인다. 실제로는 필요 없는 로직이므로 컴파일러는 이를 무시한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;28-비트코인의-블럭-tx-구조를-간략히-설명하고-utxo-를-사용--검증하기-위한-과정을-설명하시오&quot;&gt;28. 비트코인의 블럭, TX 구조를 간략히 설명하고, UTXO 를 사용 / 검증하기 위한 과정을 설명하시오.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;(1) 블럭 구조&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;블럭 헤더
    &lt;ul&gt;
      &lt;li&gt;버전&lt;/li&gt;
      &lt;li&gt;시간&lt;/li&gt;
      &lt;li&gt;이전 블럭 해시&lt;/li&gt;
      &lt;li&gt;이전 블럭의 블럭 해시 (헤더의 모든 구성 요소에 해시 함수를 적용하여 계산)&lt;/li&gt;
      &lt;li&gt;머클 루트&lt;/li&gt;
      &lt;li&gt;bits&lt;/li&gt;
      &lt;li&gt;nonce&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트랜잭션 데이터
    &lt;ul&gt;
      &lt;li&gt;트랜잭션 개수&lt;/li&gt;
      &lt;li&gt;트랜잭션 리스트&lt;/li&gt;
      &lt;li&gt;머클 트리
        &lt;ul&gt;
          &lt;li&gt;블럭내 모든 트랜잭션들의 요약 정보&lt;/li&gt;
          &lt;li&gt;이를 통해 한 트랙잭션이 블럭에 포함되는지 확인 가능&lt;/li&gt;
          &lt;li&gt;트랜잭션의 내용이나 순서가 바뀌면 머클 루트도 바뀜&lt;/li&gt;
          &lt;li&gt;데이터 무결성 및 유효성 증명 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(2) TX 구조&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버전&lt;/li&gt;
  &lt;li&gt;locktime : 설정 시간 이후의 블럭만 이 트랜잭션을 포함할 수 있음&lt;/li&gt;
  &lt;li&gt;vin (리스트 형태)
    &lt;ul&gt;
      &lt;li&gt;txid : 어떤 UTXO를 사용할지에 대한 참조&lt;/li&gt;
      &lt;li&gt;vout&lt;/li&gt;
      &lt;li&gt;scriptSig (소유권 증명을 위한 unlocking script)&lt;/li&gt;
      &lt;li&gt;sequence&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;vout (리스트 형태로)
    &lt;ul&gt;
      &lt;li&gt;value : 금액&lt;/li&gt;
      &lt;li&gt;scriptPubKey : 사용하기 위해 필요한 조건을 결정하는 암호 퍼즐 (locking script)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(3) UTXO의 사용 및 검증&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;블럭체인을 탐색하여 사용할 수 있는 UTXO를 가져옴&lt;/li&gt;
  &lt;li&gt;사용 금액에 맞추어 UTXO를 조합하며 사용하고자 하는 금액 이상의 UTXO를 사용한다면 거스름돈이 발생&lt;/li&gt;
  &lt;li&gt;scriptSig (unlocking script)
    &lt;ul&gt;
      &lt;li&gt;사용하기 위한 조건을 만족하는지 확인&lt;/li&gt;
      &lt;li&gt;디지털 서명과 공개키를 사용하여 소유권 증명&lt;/li&gt;
      &lt;li&gt;locking script를 해제하여 output의 사용 권한을 획득&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;scriptPubKey (locking script)
    &lt;ul&gt;
      &lt;li&gt;미래에 output을 사용하는 경우 만족해야 하는 조건을 지정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두 script가 이어져 실행 되며 마지막에 스택에 남아있는 True, False 값에 따라 UTXO 사용 여부가 결정 됨
    &lt;ul&gt;
      &lt;li&gt;unlocking script : &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sig&amp;gt; &amp;lt;pubKey&amp;gt;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;locking script : &lt;code class=&quot;highlighter-rouge&quot;&gt;OP_DUP OP_HASH160 &amp;lt;hash160(pubKey)&amp;gt; OP_EQUAL OP_CHECKSIG&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;unlocking script가 locking script 조건을 만족하면 input은 유효함&lt;/li&gt;
  &lt;li&gt;검증 절차는 트랜잭션이 전파될 때 비트코인 네트워크의 모든 full node들에서 실행됨&lt;/li&gt;
  &lt;li&gt;검증이 실패하는 경우 유효하지 않는 트랜잭션으로 간주되어 전파되지 않으므로 마이닝 대상에서 제외됨&lt;/li&gt;
  &lt;li&gt;signature는 사용자의 지갑에 저장되어있는 개인키로부터 생성되며 공개키는 개인키를 이용하여 생성 됨&lt;/li&gt;
  &lt;li&gt;개인키를 사용하여 트랜잭션에 서명할 수 있다면 주소의 소유자임이 증명되므로 이 UTXO를 사용할 수 있게됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;29-블록체인의-중요-요소는-해쉬함수와-머클-트리이다-해쉬-함수를-사용하는-것의-의미해쉬-함수의-특성을-설명하고-머클-트리-머클-path-를-설명하시오&quot;&gt;29. 블록체인의 중요 요소는 해쉬함수와 머클 트리이다. 해쉬 함수를 사용하는 것의 의미(해쉬 함수의 특성)을 설명하고, 머클 트리, 머클 path 를 설명하시오.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;(1) 해쉬 함수&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;임의의 길이를 가진 어떤 임의의 데이터를 일정한 길이의 어떤 데이터로 바꿔주는 함수&lt;/li&gt;
  &lt;li&gt;단 방향 함수로 데이터로 부터 해시 값을 구할 수는 있지만 해시 값 으로 부터 데이터를 역산하는 것은 불가능&lt;/li&gt;
  &lt;li&gt;해시 출력 값이 같은 데이터를 추측 하는 것은 매우 어려움&lt;/li&gt;
  &lt;li&gt;특정 해시 값이 나오는 데이터를 찾으려면 많은 경우의 수의 데이터 확인 필요&lt;/li&gt;
  &lt;li&gt;한 글자만 바뀌어도 전혀 다른 해시 값이 나오기 때문에 데이터 변조 유무 검사에 적합&lt;/li&gt;
  &lt;li&gt;블록체인의 각 블록은 해시 함수로 연결 되어있음&lt;/li&gt;
  &lt;li&gt;한 블록의 내용이 바뀌면 연쇄적으로 해시 값이 바뀌므로 블록 체인의 조작은 매우 어려움&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(2) 머클 트리&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해쉬 값을 이진 트리 형태로 구성&lt;/li&gt;
  &lt;li&gt;각 leaf 노드는 데이터 블럭의 해쉬 값이며 부모 노드는 자식 노드들의 해쉬 값임&lt;/li&gt;
  &lt;li&gt;분산 시스템의 데이터 유효성 검증에 주로 사용됨&lt;/li&gt;
  &lt;li&gt;데이터 모두를 사용하는 대신 해쉬 값만 사용하므로 효율적임&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(3) 머클 path&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;트랜잭션이 특정 블럭에 속했는지 확인하기 위하여 모든 트랜잭션들을 가져올 필요 없이 머클 패스를 사용&lt;/li&gt;
  &lt;li&gt;대상 트랜잭션의 노드 부터 루트 노드 까지 경로 중 각 노드의 짝(형제) 노드의 해쉬 값만 알면 됨&lt;/li&gt;
  &lt;li&gt;형제 노드의 해쉬 값과 부모 노드의 해쉬 값을 알면 나머지 한 형제의 해쉬 값이 올바른지 알 수 있기 때문&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 03 Jul 2018 15:50:00 +0900</pubDate>
      </item>
    
      <item>
        <title>AWS에서 Kubernetes클러스터 구축하기 (2) - NFS</title>
        <link>http://localhost:4000/dev/2018/04/27/KubernetesNFS.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2018/04/27/KubernetesNFS.html</guid>
        <description>&lt;p&gt;Kubernetes에서 NFS를 이용하여 컨테이너 간 파일 공유가 가능하도록 합니다.
이름이 &lt;code class=&quot;highlighter-rouge&quot;&gt;mynfs&lt;/code&gt;인 PersistentVolume과 PersistentVolumeClaim을 각각 생성하고 동일한 볼륨을 사용하는 두 개의 컨테이너 &lt;code class=&quot;highlighter-rouge&quot;&gt;mypod&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;mypod-2nd&lt;/code&gt;를 생성합니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;mypod&lt;/code&gt;에서 볼륨 디렉토리에 &lt;code class=&quot;highlighter-rouge&quot;&gt;test_file&lt;/code&gt;이라는 파일을 만든 다음 &lt;code class=&quot;highlighter-rouge&quot;&gt;mypod-2nd&lt;/code&gt;에서 해당 파일이 동일하게 생성되었는지 확인 합니다.
CMD-client에서도 NFS를 마운트 하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;test_file&lt;/code&gt;을 확인합니다.&lt;/p&gt;

&lt;h3 id=&quot;nfs서버-설치&quot;&gt;NFS서버 설치&lt;/h3&gt;

&lt;p&gt;AWS에서 제공하는 NFS 서버인 &lt;code class=&quot;highlighter-rouge&quot;&gt;EFS&lt;/code&gt;를 설치하여 사용합니다.&lt;/p&gt;

&lt;h4 id=&quot;보안-그룹-추가&quot;&gt;보안 그룹 추가&lt;/h4&gt;

&lt;p&gt;NFS를 위한 보안 그룹을 만들고 아래 목록에 해당하는 보안 그룹에 속한 EC2 인스턴스에서 접근 가능하도록 인바운드 규칙을 추가합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CMD-client 보안 그룹&lt;/li&gt;
  &lt;li&gt;Kubernetes 마스터 노드 보안 그룹 (&lt;code class=&quot;highlighter-rouge&quot;&gt;masters.dev.example.com&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Kubernetes 나머지 노드 보안 그룹 (&lt;code class=&quot;highlighter-rouge&quot;&gt;nodes.dev.example.com&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;유형을 NFS로 하고 소스를 각 보안 그룹으로 설정하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018/05/efs-securitygroup.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;NFS 보안 그룹 추가&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;efs-설치&quot;&gt;EFS 설치&lt;/h4&gt;

&lt;p&gt;AWS 콘솔의 서비스 -&amp;gt; EFS -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Create file system&lt;/code&gt;으로 들어갑니다.&lt;/p&gt;

&lt;p&gt;Security Groups에 위에서 만들어둔 NFS 보안 그룹을 추가합니다. 이를 통해 CMD-client와 Kubernetes 노드에서 NFS 서버에 접속 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2018/05/create_efs.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;EFS&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;kubernetes-볼륨-및-컨테이너-생성&quot;&gt;Kubernetes 볼륨 및 컨테이너 생성&lt;/h3&gt;

&lt;p&gt;NFS서버의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;디렉토리를 PV에 등록한 뒤 각 Pod에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;/mymnt&lt;/code&gt;디렉토리에 볼륨을 마운트하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;mypod&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;mypod-2nd&lt;/code&gt;가 같은 디렉토리를 공유합니다.&lt;/p&gt;

&lt;h4 id=&quot;persistentvolume-mynfs-생성&quot;&gt;PersistentVolume &lt;code class=&quot;highlighter-rouge&quot;&gt;mynfs&lt;/code&gt; 생성&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cat pv-volume-nfs.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;PersistentVolume&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mynfs&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;capacity&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;1Gi&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;storageClassName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;accessModes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ReadWriteMany&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;nfs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;fs-xxxxxxxx.efs.us-east-x.amazonaws.com&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create -f pv-volume-nfs.yaml
persistentvolume &quot;mynfs&quot; created
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;persistentvolumeclaim-mynfs-생성&quot;&gt;PersistentVolumeClaim &lt;code class=&quot;highlighter-rouge&quot;&gt;mynfs&lt;/code&gt; 생성&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cat pvc-volume-nfs.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;PersistentVolumeClaim&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mynfs&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;accessModes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ReadWriteMany&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;100Mi&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;storageClassName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create -f pvc-volume-nfs.yaml
persistentvolumeclaim &quot;mynfs&quot; created
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;mypod-생성&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mypod&lt;/code&gt; 생성&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cat pv-pod.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mypod&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myvol&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;persistentVolumeClaim&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
       &lt;span class=&quot;s&quot;&gt;claimName&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mynfs&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;my-container&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;python&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/bin/bash&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;-c&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;--&quot;&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;true;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;30;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;done;&quot;&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;80&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;http-server&quot;&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;volumeMounts&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mountPath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/mymnt&quot;&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myvol&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create -f pv-pod.yaml
pod &quot;mypod&quot; created
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;mypod-2nd-생성&quot;&gt;mypod-2nd 생성&lt;/h4&gt;

&lt;p&gt;설정 파일 내용은 name을 제외한 모든 내용이 &lt;code class=&quot;highlighter-rouge&quot;&gt;mypod&lt;/code&gt;과 동일합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cat pv-pod-2nd.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;mypod-2nd&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create -f pv-pod-2nd.yaml
pod &quot;mypod-2nd&quot; created
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;파일-공유-테스트&quot;&gt;파일 공유 테스트&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mypod&lt;/code&gt;에서 생성한 파일이 &lt;code class=&quot;highlighter-rouge&quot;&gt;mypod-2nd&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD-client&lt;/code&gt;에 공유 되는지 확인 합니다.&lt;/p&gt;

&lt;h4 id=&quot;mypod에서-test_file파일-생성&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mypod&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;test_file&lt;/code&gt;파일 생성&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl exec -it mypod -- /bin/bash

root@mypod:/# cd /mymnt
root@mypod:/mymnt# touch test_file
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;mypod-2nd에서-test_file파일-확인&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mypod-2nd&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;test_file&lt;/code&gt;파일 확인&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl exec -it mypod-2nd -- /bin/bash

root@mypod-2nd:/# ls /mymnt/
test_file
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cmd-client에서-test_file파일-확인&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD-client&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;test_file&lt;/code&gt;파일 확인&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo mkdir efs
$ sudo mount -t nfs4 -o nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2 fs-xxxxxxxx.efs.us-west-x.amazonaws.com:/ efs

$ ls ./efs/
test_file
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;지난번 포스트를 통해 AWS에서 Kubernetes를 설치하는 방법을 알아보았고 이번에는 컨테이너(Pod)와 볼륨(PV,PVC)이 제대로 생성되고 NFS를 통해 컨테이너 간 파일 공유가 정상적으로 이루어지는지 확인하였습니다. AWS 및 Kubernetes 사용에 참고 바랍니다.&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Apr 2018 15:50:00 +0900</pubDate>
      </item>
    
      <item>
        <title>AWS에서 Kubernetes클러스터 구축하기 (1)</title>
        <link>http://localhost:4000/dev/2018/03/14/KubernetesOnAWS.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2018/03/14/KubernetesOnAWS.html</guid>
        <description>&lt;p&gt;AWS에서 Kubernetes 클러스터를 구축합니다.
Hyperledger Fabric를 이용하여 블록체인 네트워크를 구축하던 중 Kubernetes 관련 부분을 따로 정리해두면 좋을 것 같아 포스팅합니다.&lt;/p&gt;

&lt;p&gt;전체 설치 과정은 이 곳(&lt;a href=&quot;https://hackernoon.com/how-to-deploy-hyperledger-fabric-on-kubernetes-1-a2ceb3ada078&quot;&gt;https://hackernoon.com/how-to-deploy-hyperledger-fabric-on-kubernetes-1-a2ceb3ada078&lt;/a&gt;)에서 확인 가능합니다. 설치 파일 공유를 위해 NFS를 사용하는데 그 부분은 별도의 포스트에 정리할 계획입니다.&lt;/p&gt;

&lt;h4 id=&quot;서버-구성&quot;&gt;서버 구성&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;명령어 실행을 위한 CMD-client 서버 1개&lt;/li&gt;
  &lt;li&gt;총 5개 노드(Master 1개, Worker 4개)로 구성된 Kubernetes클러스터&lt;/li&gt;
  &lt;li&gt;파일 공유를 위한 NFS 서버 1개&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CMD-client, Kubernetes 클러스터, NFS 서버가 모두 하나의 VPC안에 있어야합니다. VPC가 다른 경우 서로 연결하기 힘들 수도 있으니 주의하길 바랍니다.&lt;/p&gt;

&lt;h4 id=&quot;cmd-client-생성&quot;&gt;CMD-client 생성&lt;/h4&gt;
&lt;p&gt;먼저 명령어 실행을 위한 EC2 인스턴스를 생성 합니다. 많은 리소스가 필요 없으므로 CPU 1개, 메모리 2GB의 t2.small EC2 인스턴스를 사용합니다. 설치 과정은 쉬우므로 생략합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/cmd_client.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;명령어 실행용 EC2 인스턴스&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;관리-tool-설치&quot;&gt;관리 tool 설치&lt;/h4&gt;

&lt;p&gt;CMD-client에서 다음과 같이 kubectl과 kops를 설치합니다.&lt;/p&gt;

&lt;p&gt;kubectl 설치 (&lt;a href=&quot;https://kubernetes.io/docs/tasks/tools/install-kubectl/&quot;&gt;https://kubernetes.io/docs/tasks/tools/install-kubectl/&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -LO https://storage.googleapis.com/kubernetes-release/release/&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/bin/linux/amd64/kubectl
chmod +x ./kubectl
sudo mv ./kubectl /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;kops 설치 (&lt;a href=&quot;https://kubernetes.io/docs/getting-started-guides/kops/&quot;&gt;https://kubernetes.io/docs/getting-started-guides/kops/&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://github.com/kubernetes/kops/releases/download/1.8.0/kops-linux-amd64
chmod +x kops-linux-amd64
sudo mv kops-linux-amd64 /usr/local/bin/kops
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;dns-설정&quot;&gt;DNS 설정&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;example.com&lt;/code&gt; 도메인을 가지고있는 경우 Route53 설정을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;dev.example.com&lt;/code&gt;을 사용할 수 있습니다.
서비스 -&amp;gt; Route53 -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Hosted zones&lt;/code&gt;으로 들어가 새로운 HostedZone을 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/CreateHostedZone.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;dev.example.com 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;자동으로 생성된 2개의 Record Set중에 NS타입의 value를 복사합니다.
&lt;img src=&quot;/assets/img/GetValues.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;Record Set 복사&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;부모 도메인 &lt;code class=&quot;highlighter-rouge&quot;&gt;example.com&lt;/code&gt;의 설정으로 들어가 &lt;code class=&quot;highlighter-rouge&quot;&gt;dev.example.com&lt;/code&gt;의 Record Set을 등록해야 합니다.
Type을 NS로 지정한 뒤 복사했던 값을 Value에 붙여넣으면 됩니다.
부모 도메인을 AWS에서 구매한 경우에는 아래와 같이 설정할 수 있습니다.
비슷한 화면이지만 아래는 &lt;code class=&quot;highlighter-rouge&quot;&gt;example.com&lt;/code&gt;도메인을 구입했던 다른 AWS계정의 Route53 설정으로 만약 AWS가 아닌 다른 곳에서 도메인을 구입했다면 그에 맞는 방법으로 등록해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/CreateRecordSetOrigin.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;Record Set 등록&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dig NS dev.example.com&lt;/code&gt;명령을 실행했을 때 다음과 같이 4개의 NS가 나오면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;dig NS dev.xiilabcoin.com

;; ANSWER SECTION:
dev.example.com.	60	IN	NS	ns-xxxx.awsdns-xx.co.uk.
dev.example.com.	60	IN	NS	ns-xxx.awsdns-xx.com.
dev.example.com.	60	IN	NS	ns-xxx.awsdns-xx.net.
dev.example.com.	60	IN	NS	ns-xxxx.awsdns-xx.org.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;s3버킷-생성&quot;&gt;S3버킷 생성&lt;/h4&gt;

&lt;p&gt;CLI를 통해 AWS에 접근하기 위해서는 액세스 키가 필요합니다.
내 보안 자격 증명 -&amp;gt; 사용자 -&amp;gt; 아이디 클릭 -&amp;gt; 액세스 키 만들기 클릭을 통해 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/SecurityCredentials.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;액세스 키 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;생성된 액세스 키를 다음과 같이 등록하여 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;ubuntu@ip-172-xx-xx-xx:~$ &lt;/span&gt;aws configure
AWS Access Key ID &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;****************&lt;/span&gt;LPDQ]: xxxxxxxxxxxx
AWS Secret Access Key &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;****************&lt;/span&gt;UIXT]: xxxxxxxxxxxx
Default region name &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;us-east-x]:
Default output format &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;json]:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;클러스터 설정 정보 저장을 위한 S3버킷을 생성합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;ubuntu@ip-172-xx-xx-xx:~$ &lt;/span&gt;aws s3 mb s3://dev.example.com
make_bucket: dev.example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;kops-설정-및-실행&quot;&gt;kops 설정 및 실행&lt;/h4&gt;

&lt;p&gt;키교환을 위한 ssh키를 생성합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;ubuntu@ip-172-xx-xx-xx:~/.ssh$ &lt;/span&gt;ssh-keygen
Generating public/private rsa key pair.

Your identification has been saved &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /home/ubuntu/.ssh/id_rsa.
Your public key has been saved &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /home/ubuntu/.ssh/id_rsa.pub.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;kops를 사용하기 위해 환경 변수를 설정합니다. VPC_ID와 NETWORK_CIDR은 AWS 콘솔의 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC대시보드&lt;/code&gt;에서 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KOPS_STATE_STORE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;s3://dev.example.com
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CLUSTER_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;dev.example.com
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;VPC_ID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;vpc-xxxxxxxx
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;NETWORK_CIDR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;172.xx.x.x/16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;kops create cluster --zones&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;us-east-xx --name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CLUSTER_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; --vpc&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;VPC_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;kops edit cluster &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CLUSTER_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;설정 파일에서 다음 부분을 찾아서 cidr을 AWS VPC의 서브넷 리스트에 없는 IP로 수정 합니다.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;subnets&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;cidr&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;172.xx.xxx.0/19&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;us-east-xx&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Public&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;zone&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;us-east-xx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;kops edit ig --name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;dev.example.com nodes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;설정 파일이 열리면 4개가 생성 되도록 maxSize: 4, minSize: 4 로 설정합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;kops edit ig --name&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;dev.example.com master-us-east-xx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;설정 파일이 열리면 원하는 부분을 수정합니다. 수정 사항이 없는 경우는 그대로 종료합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;kops update cluster dev.example.com --yes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;클러스터-생성-확인&quot;&gt;클러스터 생성 확인&lt;/h4&gt;

&lt;p&gt;클러스터가 제대로 생성되었는지 다음과 같이 확인 합니다.
master 노드 하나와 다른 노드 4개로 성공적으로 설치되었음을 알 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;kops get &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CLUSTER_NAME&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;

Cluster
NAME			CLOUD	ZONES
dev.example.com	aws	us-east-xx

Instance Groups
NAME			ROLE	MACHINETYPE	MIN	MAX	ZONES
master-us-east-xx	Master	m3.medium	1	1	us-east-xx
nodes			Node	t2.medium	4	4	us-east-xx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;아래는 동일한 내용을 AWS 콘솔에서 확인한 것으로 EC2 인스턴스 5개가 성공적으로 실행 중 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ec2_instances.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;EC2 인스턴스 생성 확인&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;Kubernetes는 성공적으로 설치되었으니 실제 도커 컨테이너를 실행하여 잘 동작하는지 확인하는 일만 남았습니다.
다음 포스트에서는 NFS로 PersistentVolume을 구축하여 PersistentVolumeClaim을 통한 파일 공유가 제대로 이루어지는지를 확인하겠습니다.&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Mar 2018 15:50:00 +0900</pubDate>
      </item>
    
      <item>
        <title>AWS의 머신 러닝 서비스 알아보기</title>
        <link>http://localhost:4000/dev/2018/01/05/MachineLearningAWS.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2018/01/05/MachineLearningAWS.html</guid>
        <description>&lt;p&gt;AWS의 머신 러닝 서비스에 대해 알아보겠습니다.&lt;br /&gt;
머신 러닝을 이용한 서비스 개발시 적용한다면 생산성 향상을 기대할 수 있을 것으로 보입니다.&lt;/p&gt;

&lt;h1 id=&quot;머신-러닝-관련-aws-서비스&quot;&gt;머신 러닝 관련 AWS 서비스&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/all_ml_services.png&quot; alt=&quot;머신러닝 관련 AWS 서비스&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;machine-learning&quot;&gt;Machine Learning&lt;/h1&gt;

&lt;h2 id=&quot;amazon-sagemaker&quot;&gt;Amazon SageMaker&lt;/h2&gt;

&lt;p&gt;대규모 기계 학습 모델 구축, 학습, 배포 서비스&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/SageMaker_How_it_works.png&quot; alt=&quot;SageMaker 동작 과정&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기계 학습을 사용하려는 개발자가 일반적으로 빠른 속도를 내지 못하게 하는 모든 장벽을 제거
    &lt;ul&gt;
      &lt;li&gt;모델 구축 → 학습 → 튜닝 → 배포 각 단계의 복잡성 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기계 학습 모델을 구축, 교육 및 배포할 수 있는 모듈이 포함되어 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;학습 데이터를 손쉽게 탐색하고 시각화 할 수 있는 호스팅 Jupyter 노트북이 포함됨&lt;/li&gt;
  &lt;li&gt;가장 일반적으로 사용하는 기계 학습 알고리즘 10가지가 미리 설치 되어있음
    &lt;ul&gt;
      &lt;li&gt;Linear Learner&lt;/li&gt;
      &lt;li&gt;Factorization Machines&lt;/li&gt;
      &lt;li&gt;XGBoost Algorithm&lt;/li&gt;
      &lt;li&gt;Image Classification Algorithm&lt;/li&gt;
      &lt;li&gt;Sequence to Sequence (seq2seq)&lt;/li&gt;
      &lt;li&gt;K-Means Algorithm&lt;/li&gt;
      &lt;li&gt;Principal Component Analysis (PCA)&lt;/li&gt;
      &lt;li&gt;Latent Dirichlet Allocation (LDA)&lt;/li&gt;
      &lt;li&gt;Neural Topic Model (NTM)&lt;/li&gt;
      &lt;li&gt;DeepAR&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;콘솔에서 클릭 한 번으로 교육 및 배포&lt;/li&gt;
  &lt;li&gt;기본 요금 없이 사용한 만큼 비용 지불&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;amazon-lex&quot;&gt;Amazon Lex&lt;/h2&gt;

&lt;p&gt;대화형 인터페이스(챗봇)를 구축하는 서비스, Alexa와 동일한 딥 러닝 기술 기반&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/Diagrams_lex_bookhotel.png&quot; alt=&quot;호텔 예약 예시&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;음성 인식, 언어 이해 등의 딥러닝 문제(speech to text, 자연어 처리) 해결을 위한 툴 제공&lt;/li&gt;
  &lt;li&gt;데이터를 로딩, 저장을 위한 로직을 실행하기 위해 사용 되는 AWS Lambda와 연동하여 사용&lt;/li&gt;
  &lt;li&gt;확장 가능하고, 안전하고, 사용하기 쉬운 챗봇 구축, 배포, 모니터링 솔루션 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Multi-turn 대화 지원
    &lt;ul&gt;
      &lt;li&gt;의도가 파악된 다음 필요한 정보를 완전히 얻기 위해 사용자에게 질문해야 함&lt;/li&gt;
      &lt;li&gt;얻기 원하는 파라미터 목록과 대응되는 질문을 간단히 지정해주면 Amazon Lex가 해결해줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두 종류의 질문 제공
    &lt;ul&gt;
      &lt;li&gt;확인 질문 : 비지니스 로직 실행 전 사용자의 의도를 최종 적으로 확인&lt;/li&gt;
      &lt;li&gt;에러 핸들링 질문 : 사용자의 입력이 이해되지 않을 때 다시 묻거나 종료하는 과정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AWS Lambda 연동
    &lt;ul&gt;
      &lt;li&gt;데이터를 가져오고, 저장하거나 비지니스 로직 실행을 위한 AWS Lambda 연동을 기본적으로 제공&lt;/li&gt;
      &lt;li&gt;봇 개발에만 집중할 수 있도록 서버리스 컴퓨팅을 제공&lt;/li&gt;
      &lt;li&gt;Amazon Lambda를 통해 AWS 서비스들을 사용 가능
        &lt;ul&gt;
          &lt;li&gt;대화 상태 저장을 위해 Amazon DynamoDB를 사용&lt;/li&gt;
          &lt;li&gt;사용자 알림을 위해 Amazon SNS를 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AWS Lambda&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버 구축이나 관리가 필요 없는 코드 실행이 가능함&lt;/li&gt;
  &lt;li&gt;사용 시간 만큼만 요금을 내면 되고 코드가 실행 중이 아닐 땐 요금을 내지 않아도 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;콜센터 봇&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/diagram_Lex_Connect_appointment-reschedule.png&quot; alt=&quot;콜센터 봇 구성도&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Amazon Connect&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클라우드 기반 고객 센터 서비스로 보다 나은 고객 서비스를 저비용에 제공할 수 있게 함&lt;/li&gt;
  &lt;li&gt;전세계 Amazon 고객 서비스 직원들이 수 백만 건의 고객 대화에 사용 하는 것과 동일한 기술을 기반으로 함&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;사용자가 예약 변경을 위해 고객 서비스에 전화&lt;/li&gt;
  &lt;li&gt;Connect가 Lex를 호출하고 Lambda가 데이터베이스를 호출하여 전화 번호를 이용하여 고객 정보를 조회&lt;/li&gt;
  &lt;li&gt;고객이 예약 관련 질문을 하면 Lambda가 고객 예약 소프트웨어를 불러옴&lt;/li&gt;
  &lt;li&gt;새로운 예약 날짜가 확인 되면 Connect가 확인 메시지를 SMS를 통해 사용자에게 보냄&lt;/li&gt;
  &lt;li&gt;사용자가 새로운 예약 일정 세부 내용을 텍스트로 받게됨&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;환자 예약&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/Diagrams_lex_messaging-platform.png&quot; alt=&quot;환자 예약을 위한 Amazon Lex 구성&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Amazon CloudWatch&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS 클라우드 리소스 및 AWS에서 실행 되는 응용프로그램을 위한 모니터링 서비스&lt;/li&gt;
  &lt;li&gt;메트릭, 로그, 알람을 수집하고 자동으로 AWS 리소스 변경에 자동으로 대응할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;환자가 시설에 3시 예약을 요청&lt;/li&gt;
  &lt;li&gt;Lex가 일정 예약이 요청 되었음을 인식&lt;/li&gt;
  &lt;li&gt;Lex가 예약을 위해 사용자에게 선호하는 요일을 알려 달라고 함&lt;/li&gt;
  &lt;li&gt;예약 시간을 전달 받음 (Lambda를 통해 DB 접근, SNS 전송, 기타 AWS 서비스 연동)&lt;/li&gt;
  &lt;li&gt;Lex가 문자로 환자에게 목요일 3시에 예약 되었음을 알려 줌&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;analytics&quot;&gt;Analytics&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Amazon Athena - 서버 없는 Query 서비스&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S3에 있는 데이터를 표준 SQL을 이용하여 쉽게 분석할 수 있으며 쿼리 실행에 대해서만 요금을 내면 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amazon EMR - Hadoop&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;많은 데이터를 빠르고 비용 효율적으로 처리하기 위한 Hadoop 프레임워크를 제공&lt;/li&gt;
  &lt;li&gt;Apache Spark, HBase, Presto, Flink와 같은 오픈 소스 프레임워크를 실행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amazon Elasticsearch Service - Elasticsearch&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS에서 Elasticsearch 배포, 운영, 확장을 쉽게 만들어 줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amazon Kinesis - Streaming Data&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS에서 스트리밍 데이터로 작업하는 가장 쉬운 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amazon QuickSight - Business Analytics&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;매우 빠르고 사용이 간편한 클라우드 기반 비지니스 분석 기능으로 기존 BI솔루션의 10분의 1 비용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amazon Redshift - Data Warehouse&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;간단하고 비용효율적으로 분석 할 수 있도록 완벽하게 관리되는 페타바이트 급 데이터웨어하우스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;AWS Glue - ETL&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터를 만들고 저장&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;AWS Data Pipeline - Data Workflow Orchestration&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다른 AWS 컴퓨팅 및 스토리지 서비스는 물론 사내 데이터 소스간에 데이터를 지정된 간격으로 안정적으로 처리하고 이동할 수 있음&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 05 Jan 2018 10:50:00 +0900</pubDate>
      </item>
    
      <item>
        <title>멈춰있는 Python 프로세스 원인 찾기</title>
        <link>http://localhost:4000/dev/2017/12/21/FindCauseStoppedPythonProcess.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2017/12/21/FindCauseStoppedPythonProcess.html</guid>
        <description>&lt;p&gt;데이터 추출,변환,적재(ETL)를 위하여 Python프로세스들을 Apache NiFi에 등록하여 사용하고 있습니다. Apache NiFi는 각 프로세스의 실행 및 프로세스간 데이터 흐름을 관리합니다.&lt;/p&gt;

&lt;p&gt;데이터 수집이 잘 되고 있는지 확인하기 위하여 NiFi의 Summary메뉴로 들어가보니 AirekoreaFetcher가 멈춰있는 것이 발견되었습니다. AirkoreaFetcher는 환경 공단에서 제공하는 API를 사용하여 전국의 대기 환경 데이터를 가져오는 프로세스로 한 시간에 한 번 실행 됩니다. 프로세스의 데이터 처리량을 확인할 수 있는 Status History의 시계열 차트를 보니 하루 종일 아무 것도 없어 뭔가 문제가 있다는 것을 확인할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/NiFi_Summary.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;프로세스 멈춤 문제 발견 : Summary -&amp;gt; Status History -&amp;gt; 데이터 처리량 확인&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;어떤 이유로 이런 문제가 발생했는지 그 원인을 찾는 과정을 설명하겠습니다. NiFi를 사용하지 않는 경우에도 Python 프로세스가 멈추는 문제 발생시 동일한 방법을 적용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-실행-정보-확인&quot;&gt;프로세스 실행 정보 확인&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/airkorea_fetcher_command.png&quot; alt=&quot;&quot; /&gt;
&lt;em&gt;AirkoreaFetcher의 Python 실행 명령문&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;문제 발생 원인을 찾기 위하여 해당 프로세스의 실행 정보를 알아냅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@es04 nifi-1.2.0]# ps -ef | grep fetcher

root     25405 10961  0 12월18 ?      00:00:00 python /home/deploy/rems/rems/airkorea_fetcher.py /home/deploy/rems/conf/collectors.cfg
root     26607 25405  0 12월18 ?      00:00:00 python /home/deploy/rems/rems/airkorea_fetcher.py /home/deploy/rems/conf/collectors.cfg&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;관련 프로세스가 2개 실행 중인데 실행 시간이 3일 전인 12월 18일로 되어있어 문제가 생겨 멈춰있는 것 처럼 보입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;좀-더-디테일한-시간-찾기&quot;&gt;좀 더 디테일한 시간 찾기&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@es04 nifi-1.2.0]# ls -ld /proc/25405
dr-xr-xr-x. 9 root root 0 12월 18 03:25 /proc/25405

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@es04 nifi-1.2.0]# ls -ld /proc/26607
dr-xr-xr-x. 9 root root 0 12월 18 03:29 /proc/26607&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;PID를 이용하여 날짜 뿐만이 아닌 시간,분 까지 찾아내 로그를 분석할 때 사용합니다. 실행 시점에 실제로 어떤 일이 발생했는지 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;무엇-때문에-멈췄는지-추적&quot;&gt;무엇 때문에 멈췄는지 추적&lt;/h3&gt;

&lt;h4 id=&quot;strace&quot;&gt;strace&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strace&lt;/code&gt;를 사용하여 실행 중인 프로세스 안을 들여다 볼 수 있습니다. 프로세스가 호출하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;system call&lt;/code&gt;과 받은 &lt;code class=&quot;highlighter-rouge&quot;&gt;signal&lt;/code&gt;을 확인 가능하며 각 &lt;code class=&quot;highlighter-rouge&quot;&gt;system call&lt;/code&gt;의 이름, 인자, 리턴 값을 출력 합니다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;system call&lt;/code&gt;이란 프로세스와 Linux 커널 사이의 인터페이스로 커널을 통해 어떤 일을 처리할 때 사용합니다.)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@es04 nifi-1.2.0]# strace -p 26607
Process 26607 attached
recvfrom&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;7, ^CProcess 26607 detached
 &amp;lt;detached ...&amp;gt;

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@es04 nifi-1.2.0]# strace -p 25405
Process 25405 attached
wait4&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;26607, ^CProcess 25405 detached
 &amp;lt;detached ...&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;프로세스 실행 중엔 복잡한 내용들이 정신 없이 출력 되는 것을 볼 수 있지만 지금은 프로세스가 멈춘 상태로 마지막으로 호출된 &lt;code class=&quot;highlighter-rouge&quot;&gt;system call&lt;/code&gt; 정보만 나타납니다.&lt;/p&gt;

&lt;h4 id=&quot;gdb&quot;&gt;GDB&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strace&lt;/code&gt;를 통해선 &lt;code class=&quot;highlighter-rouge&quot;&gt;system call&lt;/code&gt; 이름과 첫 번째 인자만 확인할 수 있었는데 보다 자세한 정보를 보기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;GDB&lt;/code&gt;를 사용합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;GDB&lt;/code&gt;는 Linux에서 사용하는 디버거로 &lt;code class=&quot;highlighter-rouge&quot;&gt;strace&lt;/code&gt;와 마찬 가지로 프로세스 안을 들여다 볼 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@es04 nifi-1.2.0]# gdb

GNU gdb &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;GDB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Red Hat Enterprise Linux 7.6.1-94.el7
Copyright &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;C&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 2013 Free Software Foundation, Inc.

...

&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; attach 26607

Attaching to process 26607
Reading symbols from /usr/bin/python2.7...Reading symbols from /usr/lib/debug/usr/bin/python2.7.debug...done.
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
Reading symbols from /lib64/libpython2.7.so.1.0...Reading symbols from /usr/lib/debug/usr/lib64/libpython2.7.so.1.0.debug...done.
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
Loaded symbols &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; /lib64/libpython2.7.so.1.0
Reading symbols from /lib64/libpthread.so.0...Reading symbols from /usr/lib/debug/usr/lib64/libpthread-2.17.so.debug...done.
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Thread debugging using libthread_db enabled]
Using host libthread_db library &lt;span class=&quot;s2&quot;&gt;&quot;/lib64/libthread_db.so.1&quot;&lt;/span&gt;.
Loaded symbols &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; /lib64/libpthread.so.0
Reading symbols from /lib64/libdl.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libdl-2.17.so.debug...done.
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.

...
...

Loaded symbols &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; /lib64/libnss_files.so.2
Reading symbols from /lib64/libnss_dns.so.2...Reading symbols from /usr/lib/debug/usr/lib64/libnss_dns-2.17.so.debug...done.
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
Loaded symbols &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; /lib64/libnss_dns.so.2
0x00007fae5db8182b &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;__libc_recv &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;7, &lt;span class=&quot;nv&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;buf@entry&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0x24ca224, &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;n@entry&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8192, &lt;span class=&quot;nv&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;flags@entry&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; at ../sysdeps/unix/sysv/linux/x86_64/recv.c:33
33	  ssize_t result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; INLINE_SYSCALL &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;recvfrom, 6, fd, buf, n, flags, NULL, NULL&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;;

&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gdb&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; quit&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strace&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;GDB&lt;/code&gt;를 통해 PID &lt;code class=&quot;highlighter-rouge&quot;&gt;26607&lt;/code&gt; 프로세스가 &lt;code class=&quot;highlighter-rouge&quot;&gt;recvfrom&lt;/code&gt;함수에서 멈춰 있는 것을 확인했습니다.&lt;/p&gt;

&lt;h4 id=&quot;recvform&quot;&gt;recvform&lt;/h4&gt;

&lt;p&gt;인터넷에 &lt;code class=&quot;highlighter-rouge&quot;&gt;recvfrom&lt;/code&gt;을 검색하여 소켓 통신에서 데이터를 받아올 때 사용하는 함수라는 것을 알게되었습니다.&lt;br /&gt;
관련 링크 : &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740120(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740120(v=vs.85).aspx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;소스-코드-확인&quot;&gt;소스 코드 확인&lt;/h3&gt;

&lt;h4 id=&quot;multiprocessing&quot;&gt;multiprocessing&lt;/h4&gt;

&lt;p&gt;도대체 어느 부분이 문제인지 소스 코드 및 로그를 확인 합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fetchers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AirkoreaFetcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;station_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;station_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dt_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;station_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;station_name&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;station_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; 부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;209&lt;/code&gt; 까지의 station_id 별로 프로세스를 생성(multiprocessing 사용)하여 동시에 실행 하는 코드 인데 로그를 살펴보니 station_id가 &lt;code class=&quot;highlighter-rouge&quot;&gt;144&lt;/code&gt;일 때 시작(start_time, end_time 출력)은 있는데 끝(데이터 길이 출력)이 없는 것이 보입니다. 전체 로그를 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;144&lt;/code&gt;를 제외한 모든 station_id의 시작과 끝이 쌍을 이루고 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;...
...
2017-12-18 03:29:43 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;__main__] INFO: station_id: 0142, start_time: 2017-12-18 03:00:00, end_time: 2017-12-18 03:29:43.232133
2017-12-18 03:29:45 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;__main__] INFO: station_id: 0143, start_time: 2017-12-18 03:00:00, end_time: 2017-12-18 03:29:45.233463
2017-12-18 03:29:47 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;__main__] INFO: station_id: 0144, start_time: 2017-12-18 03:00:00, end_time: 2017-12-18 03:29:47.235439
2017-12-18 03:29:49 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;__main__] INFO: station_id: 0145, start_time: 2017-12-18 03:00:00, end_time: 2017-12-18 03:29:49.237130
2017-12-18 03:29:51 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;__main__] INFO: station_id: 0143, len&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data_list&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 1
2017-12-18 03:29:53 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;__main__] INFO: station_id: 0147, start_time: 2017-12-18 03:00:00, end_time: 2017-12-18 03:29:53.242072
2017-12-18 03:29:53 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;__main__] INFO: station_id: 0142, len&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data_list&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 0
2017-12-18 03:29:54 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;__main__] INFO: station_id: 0145, len&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data_list&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 1
2017-12-18 03:29:58 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;__main__] INFO: station_id: 0147, len&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data_list&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 1
...
...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;로그 상의 문제 발생 시점이 12월 18일 3시 29분 47초 인데 PID &lt;code class=&quot;highlighter-rouge&quot;&gt;26607&lt;/code&gt; 프로세스의 시작 시간(3시 29분)과 정확히 일치함을 볼 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;25405&lt;/code&gt; 프로세스가 부모이고 &lt;code class=&quot;highlighter-rouge&quot;&gt;26607&lt;/code&gt; 프로세스가 자식인데 &lt;code class=&quot;highlighter-rouge&quot;&gt;26607&lt;/code&gt; 프로세스는 소켓 통신 문제로 멈춰있고(시작만 있고 끝이 없음) 부모인 &lt;code class=&quot;highlighter-rouge&quot;&gt;25405&lt;/code&gt;는 자식을 기다리기 때문에 멈춰있다는 것을 유추할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;requests&quot;&gt;requests&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stationName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request_str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://openapi.airkorea.or.kr/openapi/services/rest/&quot;&lt;/span&gt;\
        &lt;span class=&quot;s&quot;&gt;&quot;ArpltnInforInqireSvc/getMsrstnAcctoRltmMesureDnsty?&quot;&lt;/span&gt;\
        &lt;span class=&quot;s&quot;&gt;&quot;stationName={0}&amp;amp;dataTerm=daily&amp;amp;pageNo=1&amp;amp;numOfRows=1&amp;amp;&quot;&lt;/span&gt;\
        &lt;span class=&quot;s&quot;&gt;&quot;ServiceKey={1}&amp;amp;ver=1.3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stationName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SERVICE_KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;response_str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_str&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;어떤 부분이 소켓 통신을 사용하는지 소스 코드를 확인해보니 &lt;code class=&quot;highlighter-rouge&quot;&gt;requests.get&lt;/code&gt;을 사용하는 부분이 있습니다. 왜 멈췄을까 고민하던 중 인터넷을 찾아보니 &lt;code class=&quot;highlighter-rouge&quot;&gt;requests.get&lt;/code&gt;의 timeout 옵션의 기본 값이 None이라는 것과 이 경우 문제가 발생하면 하염 없이 영원히 기다리게 된다는 것을 알게되었습니다.&lt;/p&gt;

&lt;p&gt;관련 링크 : &lt;a href=&quot;https://stackoverflow.com/questions/17782142/why-doesnt-requests-get-return-what-is-the-default-timeout-that-requests-get&quot;&gt;https://stackoverflow.com/questions/17782142/why-doesnt-requests-get-return-what-is-the-default-timeout-that-requests-get&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;airkorea_fetcher의 경우 timeout을 지정하지 않았기 때문에 문제가 발생했는데도 멈춰있는 상태가 되었습니다. 확인해보니 비슷한 역할을 하는 다른 프로그램에도 같은 문제가 있어 &lt;code class=&quot;highlighter-rouge&quot;&gt;requests.get&lt;/code&gt;을 사용하는 모든 부분에 timeout을 지정해주기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;멈춰 있는 Python 프로세스의 문제 원인 분석 및 해결 방안 도출 과정을 정리해보았습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;ps -ef&lt;/code&gt;명령을 사용하여 PID, 실행 시간 등의 프로세스 실행 정보를 알아낸 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;strace&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;GDB&lt;/code&gt;를 이용하여 멈춤 현상의 원인이 되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;system call&lt;/code&gt;을 확인했습니다. 알아낸 정보들과 로그를 대조하여 소스 코드의 어떤 부분이 문제가 되는지 유추하였고 그에 대한 해결책을 도출하였습니다.&lt;/p&gt;

&lt;p&gt;Python 뿐만 아니라 Linux 운영체제 상에서 실행되는 모든 프로세스의 멈춤 원인 파악에 유용하게 쓰일 수 있는 방법으로 비슷한 문제를 겪고 있는 분들께 도움이 되길 바랍니다.&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Dec 2017 10:50:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Git 베스트 프랙티스</title>
        <link>http://localhost:4000/dev/2015/08/19/GitBestPractices.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2015/08/19/GitBestPractices.html</guid>
        <description>&lt;p&gt;본격적으로 Git을 사용하기에 앞서 Git사용시 베스트 프랙티스가 무엇인지 알아보았습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-commit-하기-전에-git-diff로-코드-리뷰-버그-방지&quot;&gt;1. commit 하기 전에 git diff로 코드 리뷰 (버그 방지)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;git add –patch (diff를 하나씩 보여주면서 스테이지 여부를 물어봄)&lt;/li&gt;
  &lt;li&gt;git diff –cached (최종 커밋하기 전에 diff로 확인)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-작고-논리적인-커밋-일찍-자주하기&quot;&gt;2. 작고, 논리적인 커밋 (일찍 자주하기)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;잘 관리된 저장소의 커밋 로그는 하나의 스토리다&lt;/li&gt;
  &lt;li&gt;git status와 git diff로 변경사항 리뷰시 단일한 논리적 단위, 단순한 문장으로 설명 되어야함.&lt;/li&gt;
  &lt;li&gt;디버깅시에 커밋 단위가 잘게 나눠져있는 편이 어떤 라인에서 버그가 발생했는지 알기 용이함&lt;/li&gt;
  &lt;li&gt;가이드라인
    &lt;ul&gt;
      &lt;li&gt;절대 하나의 커밋에 여러개의 모듈들을 묶어 넣지 않는다. (여러 모듈이 타이트하게 커플링관계가 아닌 이상)&lt;/li&gt;
      &lt;li&gt;새 모듈을 작성할때 그루터기 함수들을 먼저 작성하고, 돌아와서 그 것들을 채워넣는다.&lt;/li&gt;
      &lt;li&gt;항상 API레벨의 함수들을 작성하고 커밋한다. (그 것들을 사용하는 함수들을 작성하고 커밋하기전에)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-깨끗한-커밋-히스토리를-남겨라&quot;&gt;3. 깨끗한 커밋 히스토리를 남겨라&lt;/h3&gt;
&lt;p&gt;git merge를 많이 쓰게되면 커밋 히스토리를 읽기 어려워짐&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;git rebase와 git merge의 조합을 사용할 것&lt;/li&gt;
  &lt;li&gt;push 전에 rebase할 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-절대-공유된-커밋은-리베이스-하지-말라&quot;&gt;4. 절대 공유된 커밋은 리베이스 하지 말라&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;규칙 : 한 번 원격 저장소에 푸쉬한 커밋은 리베이스하지 않기&lt;/li&gt;
  &lt;li&gt;이렇게 하면 다른 사람들의 코드를 망가뜨리지 않게 해주고, 내가 수정한 버그나 실수의 기록도 보존시켜준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-용도에-알맞게-pull-request를-사용하라&quot;&gt;5. 용도에 알맞게 pull request를 사용하라.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;팀원들이 무엇이 어떻게 돌아가는지 알 수 있게 해줌 (변경사항 추적, 커밋 연계, 개발 중 협업, 머지 전 코드 리뷰)&lt;/li&gt;
  &lt;li&gt;머지 커밋이 눈에 띄는게 유일한 단점이긴 하지만, 팀으로 일할 때 이 점은 상쇄된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-명령어를-위한-alise를-사용할-것-gitconfig에-추가&quot;&gt;6. 명령어를 위한 alise를 사용할 것 (~/.gitconfig에 추가)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[alias]
lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s \
%Cgreen(%cr, %cn)%Creset' --abbrev-commit --date=relative

hist = log --graph --pretty=format:'%h %ad | %s%d [%an]' --date=short

last = log -1 HEAD
unstage = reset HEAD --
amend = commit --amend -C HEAD
co = checkout
ci = commit
st = status
br = branch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;참고자료&quot;&gt;참고자료&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://sethrobertson.github.io/GitBestPractices/&quot;&gt;https://sethrobertson.github.io/GitBestPractices/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://chriskottom.com/blog/2014/02/a-few-modest-best-practices-for-git/&quot;&gt;http://chriskottom.com/blog/2014/02/a-few-modest-best-practices-for-git/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.lullabot.com/articles/git-best-practices-workflow-guidelines&quot;&gt;https://www.lullabot.com/articles/git-best-practices-workflow-guidelines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 19 Aug 2015 17:45:00 +0900</pubDate>
      </item>
    
      <item>
        <title>더 나은 Git 사용을 위한 명령어</title>
        <link>http://localhost:4000/dev/2015/08/17/BetterGit.html</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2015/08/17/BetterGit.html</guid>
        <description>&lt;p&gt;이미 Git을 어느 정도 사용해보았고, branch의 merge개념도 어느정도 익숙한 분들을 위한 내용입니다. 핵심적인 내용만 간단히 정리해놓았으니, 보다 자세한 내용을 원하시는 분들은 뒤에 있는 참고 사이트를 보시길 바랍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;1-merging-vs-rebasing&quot;&gt;1. merging vs rebasing&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/merge_before-New-Page.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;git rebase는 git merge와 같은 문제를 해결하기 위한 것으로, 브랜치의 변경사항을 다른 브랜치에 적용합니다. 위 그림 처럼 Master 브랜치에서 갈라져 나온 Feature 브랜치에서 작업을 하고 있는데, Master 브랜치가 변경 되었다면 변경 사항 반영을 위해 rebase 또는 merge를 택할 수 있습니다.&lt;/p&gt;

&lt;p&gt;먼저 merge의 경우를 살펴보겠습니다. 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout feature&lt;br /&gt;
git merge master&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/merge_after.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 형태로 추가적인 커밋이 하나 추가된 것을 볼 수 있습니다. 머지의 장점은 비파괴적(non-destructive)이라는 것입니다, 기존 커밋들은 아무것도 바뀌지 않았습니다. rebase가 가지고 있는 잠재적 위험 요소를 제거합니다. 하지만 정돈되지않은 머지커밋들이 늘어나면 다른 개발자가 히스토리를 읽기 어려워 질수도 있습니다.&lt;/p&gt;

&lt;p&gt;리베이스의 경우를 살펴 봅시다. 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout feature&lt;br /&gt;
git rebase master&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feature 브랜치 전체를 Master 브랜치의 끝으로 이동하고, Master 브랜치의 모든 새로운 커밋을 반영했습니다. 머지와 달리 새로운 커밋들을 생성하면서 히스토리를 다시 쓰게되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/rebase.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이미지는 위와 같습니다. 장점은 깨끗한 히스토리를 얻게된다는 것입니다. 완전히 선형적인 구조이기 때문에 git log, git bisect, git gitk등으로 탐색하기가 쉽습니다. 이렇게 새 것같은 커밋 히스토리에는 트레이드오프가 있습니다. 히스토리를 다시 씀으로인해 잠재적으로 협업 워크플로우에 큰 지장을 초래할 수도 있기에 주의해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;인터랙티브 리베이싱&lt;/strong&gt;이라는 것도 있습니다. 이를 이용하면 현재 작업중인 브랜치에서 여러개의 커밋을 한꺼번에 수정할 수 있습니다. 커밋의 순서를 바꾸거나 합치기 등이 가능합니다. 보통 feature 브랜치를 master 브랜치로 머지하기 전 지저분한 히스토리를 정리하기위해 사용합니다.&lt;/p&gt;

&lt;p&gt;명령은 i 옵션을 주면 됩니다. 아래는 최근 3개의 커밋을 수정하기위한 명령입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git rebase -i HEAD~3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;실행하면 편집기가 열리고 아래와 같이 각 각의 커밋 앞에 수행할 명령(pick, fixup등)을 적게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;pick 33d5b7a Message for commit #1&lt;br /&gt;
pick 9480b3d Message for commit #2&lt;br /&gt;
pick 5c67e61 Message for commit #3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 리스트는 리베이스가 끝난 뒤 브랜치가 어떻게 보여질 것인가를 정의하는 것입니다. 순서를 바꿀수도 있고, 아래와 같이 fixup으로 바꾼 뒤 저장하면 두 번째 커밋이 바로 전 커밋인 첫 번째 커밋으로 합쳐지게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;pick 33d5b7a Message for commit #1&lt;br /&gt;
fixup 9480b3d Message for commit #2&lt;br /&gt;
pick 5c67e61 Message for commit #3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2-커밋을-가리키는-상대적인-방법&quot;&gt;2. 커밋을 가리키는 상대적인 방법&lt;/h3&gt;

&lt;p&gt;커밋을 가리키는 다양한 방법들이 있지만 여기서는 쉽고 자주 쓰이는 상대적인 방법에 대해 설명합니다. HEAD^ 과 HEAD~ 둘 다 HEAD를 기준으로 부모를 가리키는데, HEAD^숫자 와 HEAD~숫자인 경우 헷갈리지 말아야할 것은 ^는 머지 커밋이 있는 경우 여러 부모가 있을 때 몇 번째 부모인지를 나타내는 반면 ~는 조부모를 가리킵니다. 다음 예제를 보면 좀 더 명확히 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/ref.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3-되돌리기-reset-checkout-revert&quot;&gt;3. 되돌리기 (reset, checkout, revert)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;31-reset&quot;&gt;3.1 reset&lt;/h4&gt;

&lt;p&gt;브랜치의 끝을 다른 커밋으로 이동하는 것입니다. 다음과 같이 커밋들을 지우는데 사용 가능합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout hotfix&lt;br /&gt;
git reset HEAD~2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 하면 끝의 두 커밋은 댕글링 커밋(가비지 컬렉션 대상)이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/reset.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;옵션에 따라 적용되는 범위가 다릅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;soft : 커밋 히스토리에만 영향을 줍니다.&lt;/li&gt;
  &lt;li&gt;mixed : 기본값이며, 커밋 히스토리와 스테이지에 영향을 줍니다.&lt;/li&gt;
  &lt;li&gt;hard : 커밋 히스토리, 스테이지, 워킹디렉토리 모두에 영향을 줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가장 많이 쓰는 경우는 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git reset –mixed HEAD^ : 최근 커밋 취소 (스테이지도 함께 취소)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;32-checkout&quot;&gt;3.2 checkout&lt;/h4&gt;

&lt;p&gt;브랜치를 checkout했던 것처럼 커밋 주소를 통해서도 checkout하는것이 가능합니다. 브랜치의 경우와 마찬가지로 HEAD참조를 특정한 커밋으로 옮깁니다. 예를 들면 다음 명령은 현재 커밋의 조부모로 체크아웃 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout HEAD~2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/checkout.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오래된 버전의 프로젝트를 살펴볼때 유용하지만, 현재 HEAD를 가리키는 브랜치 참조가 없어서 detached HEAD 상태가 됩니다. 이 상태에서 커밋을 하고 다른 브랜치로 스위칭을 하면 변경 사항들을 잃어버릴 수가 있습니다. 그래서 커밋을 할 때는 새로운 브랜치를 생성하는게 좋습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;33-revert&quot;&gt;3.3 revert&lt;/h4&gt;

&lt;p&gt;새로운 커밋을 생성하여 되돌리기를 하는 방법입니다. 커밋 히스토리를 건드리지 않기 때문에 안전합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git revert HEAD~2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/revert.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림을 보면 B라는 커밋이 새로 생성되었는데, 두 번째 전으로 revert되었기 때문에 A커밋의 상태와 동일합니다. 원격 저장소에 푸쉬한 경우 이 방법으로 되돌리기가 가능합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4-stash&quot;&gt;4. stash&lt;/h3&gt;

&lt;p&gt;스테이지에 있는 파일들을 스택에 잠시 저장해두는 명령어 입니다. 어떤 브랜치에서 작업중인데 다른 브랜치로 잠시 이동(checkout)해야 할 경우 유용합니다. 다른 브랜치에서의 작업이 끝나면 다시 돌아온 뒤 스택에서 꺼내면 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;git stash : 스테이지에 있는 파일들과 tracked 이면서 modified인 파일들을 스택에 저장합니다.&lt;/li&gt;
  &lt;li&gt;git list : 스택에 저장된 것들을 목록을 보여줍니다.&lt;/li&gt;
  &lt;li&gt;git pop : 스택에서 꺼내서 현재 브랜치에 적용합니다. 이 때 stash 했던 브랜치여야 할 필요는 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;참고reference&quot;&gt;참고(reference)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.atlassian.com/git/tutorials/advanced-overview/&quot;&gt;http://www.atlassian.com/git/tutorials/advanced-overview/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/ko/v2/&quot;&gt;http://git-scm.com/book/ko/v2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 17 Aug 2015 17:45:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
